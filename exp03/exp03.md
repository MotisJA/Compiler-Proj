# 实验三：本地寄存器分配器

在本部分实验中，你的任务是实现一对本地寄存器分配算法——自上而下和自下而上。您的程序将以包含一系列IR操作（以ILOC IR的子集表示），使用自上而下和自下而上的方法进行寄存器分配（术语请参考教材Engineering a Compiler的13.3节。），并产生一系列ILOC操作作为输出。输入和输出程序应该在以下意义上等效：

    在本实验中，输入程序和输出程序被视为等价，当且仅当它们向标准输出（stdout）打印相同的值，并且输入程序执行时定义的每个数据内存位置在输出程序执行时接收到相同的值。

为简化问题，输入程序是自包含的，它不读取任何输入文件。它使用的所有数据都包含在程序本身中。
你的实验应执行寄存器分配，但不进行其他优化。由于所有输入数据都直接编码在程序中，因此你的实验在理论上可以执行该程序，并用一系列输出语句和少量内存写入来替换它。（是的，有学生这样做过。）这种优化是禁止的。任何不包含输入程序所有算术操作的输出程序将被视为不正确。这个实验的目的是集中关注简单寄存器分配器中出现的问题，而不是利用ILOC测试程序的简化形式。

## 具体要求

为方便调试和给分，你的本地寄存器分配器需要3个命令行参数。具体地，你需要实现以下命令行参数：

| 参数               | 描述                                                                 |
|--------------------|----------------------------------------------------------------------|
| 一个整数 k         | 指定分配器将在目标机器上假定可用的寄存器数量。                      |
| 一个单字符的 flag  | 字符 `t` 或 `b` 表示在当前执行中使用哪种算法。`t` 表示自顶向下的方法，而 `b` 表示自底向上的方法。 |
| 一个文件名         | 此参数指定输入文件的名称。它是相对于当前工作目录的有效 Linux 路径名。 |

你的代码应对命令行参数的正确性进行检查。如果 k不是正整数，请输出合理且有信息量的提示。如果第二个参数不是t或b，也请输出合理且有信息量的提示。如果无法读取指定的文件，请输出合理且有信息量的提示。
输入文件将包含一系列操作，写在第6.2节描述的ILOC子集中的。输出文件将包含一个等价的 ILOC操作序列，仅使用从 1 到 k编号的寄存器。
你的实验可执行文件应命名为 412alloc。它应将输出文件写入标准输出（stdout），并将错误消息（如果有）写入标准错误（stderr）。因此，命令行应该是：
`412alloc 5 t block1.i`
将使用自顶向下算法对文件 block1.i 中的代码进行处理，并为一个五寄存器的机器进行分配，将输出写入标准输出（stdout）。

## ILOC子集

本实验的输入和输出文件都由一个单一的基本代码块组成，使用 ILOC的子集编写。教材Engineering a Compiler的附录 A 提供了关于书中使用的 ILOC 版本的有限细节。本实验子集中的大多数操作在附录 A中有定义。我们添加了一项操作 output，用于打印内存中的值。
具体来说，你的实验必须支持以下操作：

| Syntax       | Meaning                   | Latency |
|--------------|---------------------------|---------|
| load r1 ⇒ r2 | r2 ← MEM(r1)              | 2       |
| loadI x ⇒ r2 | r2 ← x                    | 1       |
| store r1 ⇒ r2| MEM(r2) ← r1              | 2       |
| add r1, r2 ⇒ r3 | r3 ← r1 + r2           | 1       |
| sub r1, r2 ⇒ r3 | r3 ← r1 - r2           | 1       |
| mult r1, r2 ⇒ r3 | r3 ← r1 * r2          | 1       |
| lshift r1, r2 ⇒ r3 | r3 ← r1 << r2       | 1       |
| rshift r1, r2 ⇒ r3 | r3 ← r1 >> r2       | 1       |
| output x     | prints MEM(x) to stdout   | 1       |

所有寄存器名称的格式为以字母 r 开头，后面跟一个非负整数。寄存器名称中的前导零不具有重要意义，因此 r017 和 r17 指的是同一个寄存器。代码中会包含逗号和赋值符号（ $\Rightarrow$ ）。符号之间的空格是可选的。

## 提交内容

第三次提交的内容是你所完成的本地寄存器分配器。你需要提交分配器的代码，这些代码必须能够运行。你需要给出三个例子的输入及运行结果，来说明你的分析器，至少对这三个例子是可以正常工作的。此外，对于非法的输入，你的分析器应该给出有用的错误提示及诊断信息。助教将对你提交的代码进行检查和测试。我们将更多的测试输入来检测你的分析器是否可以正常工作。这些输入我们不会公开。

